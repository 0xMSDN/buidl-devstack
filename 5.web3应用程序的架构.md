### Web 3.0 应用程序的架构

先说个结论：Web3应用程序（或DApps）的架构与Web2应用程序完全不同。

我们以一个简单的博客网站为例，让用户发布自己的内容并与他人的内容互动。作为一个 web2应用程序，大概的架构是这样的：

- **首先**：必须有一个地方来存储基本数据，如用户、帖子、标签、评论等等。这需要一个不断更新的数据库
- **其次**：后端代码（用C#、Java、Go或Python等语言编写）必须定义博客的业务逻辑。例如，当一个新用户注册、发表新博客或在别人的博客上发表评论时会发生什么？
- **最后**：前端代码（通常用JavaScript、HTML和CSS编写）必须定义博客的用户界面逻辑。例如，网站是什么样子的，当用户与页面上的每个元素互动时，会发生什么？

我们把这一切放在一起，当你在博客上写一篇文章时，你与它的前端互动，它与它的后端对话，后端再与它的数据库对话。所有这些代码都托管在集中式服务器上，并通过互联网浏览器发送给用户。这是对当今大多数Web 2.0应用如何工作的一个很好的总结。

<div align=center><img src="./web3应用程序的架构/web3infra1.png" width="40%"/></div>

但所有这一切都在改变。区块链技术为Web3.0应用解锁了一个令人兴奋的新方向。所以我们将重点讨论以太坊区块链带来的新变化。

### 是什么让Web 3.0与众不同？

与像微博这样的 Web 2.0 应用程序不同，Web 3.0 消除了中间人。没有储存应用状态的中央数据库，也没有储存后端逻辑的中央 Web 服务器。相反，您可以利用区块链在由互联网上匿名节点维护的分布式状态机上构建应用程序。

"状态机"是指维护某个给定程序状态和允许在该机器上的未来状态的机器。区块链是以某些初始状态实例化的状态机，并且具有非常严格的规则（即共识），定义了如何转换该状态。更好的是，没有单个实体控制这个分布式状态机——它由网络中的所有人共同维护。

那后端服务器呢？Web 3.0 中，您可以编写定义应用程序逻辑的智能合约，并将它们部署到分布式状态机上，而不是像 Medium 的后端一样由单个实体控制。这意味着每个想要构建区块链应用程序的人都会在这个共享状态机上部署他们的代码。

前端呢？基本上保持不变，有一些例外情况，我们将在稍后讨论。

这是架构的样子：
<div align=center><img src="./web3应用程序的架构/web3infra2.png" width="40%"/></div>


### 思考一些问题

现在，让我们更深入地了解使这一切成为可能的原因。

1、区块链（Blockchain）<br>以太坊区块链通常被吹捧为“世界计算机”。这是因为它是一台由点对点网络的节点维护的、全球可访问的、确定性的状态机。该状态机上的状态变化由网络中的节点遵循的共识规则管理。换句话说，它被设计为世界上任何人都可以访问和写入的状态机。原因是这台机器不属于任何单一实体，而是由网络中的所有人共同拥有。还有一件事要知道：数据只能被写入以太坊区块链，而你永远不能更新现有的数据。

2、智能合约（Smart contracts）<br>![smartcontract](./web3应用程序的架构/smartcontracts.png) <br>智能合约是在以太坊区块链上运行的程序，它定义了区块链上发生的状态变化背后的逻辑。智能合约使用高级语言（例如 Solidity 或 Vyper）编写。由于智能合约代码存储在以太坊区块链上，因此任何人都可以检查网络上所有智能合约的应用程序逻辑。

3、Ethereum Virtual Machine（EVM）<br>接下来是以太坊虚拟机，它执行智能合约中定义的逻辑，并处理全局可访问的状态机上发生的状态更改。但是EVM不理解像 Solidity 和 Vyper 这样的高级语言，这些语言用于编写智能合约。相反，你必须将高级语言编译成字节码，然后 EVM 才能执行它。

4、Front-end<br>最后是前端。正如我们之前提到的，它定义了 UI 逻辑，但前端也与智能合约中定义的应用逻辑进行通信。

### 前端代码如何与以太坊上的智能合约进行通信？

前端与智能合约之间的通信比上图中看起来要复杂一些。下面我们来仔细看看。

我们希望前端能够与智能合约进行通信，以便调用函数，但要记住，以太坊是一个去中心化的网络。以太坊网络中的每个节点都保留了以太坊状态机上所有状态的副本，包括与每个智能合约相关的代码和数据。

当我们希望与区块链上的数据和代码进行交互时，我们需要与其中一个节点进行交互。这是因为任何节点都可以广播要求在 EVM 上执行事务的请求。矿工将执行事务，并将结果状态更改传播到网络的其余部分。

有两种方法可以广播一个新的交易：<br>1、设置自己的节点，运行以太坊区块链软件<br>2、使用Infura、Alchemy和Quicknode等第三方服务提供的节点<br>

如果使用第三方服务，就不必自己处理运行完整节点的所有问题。毕竟，在自己的服务器上设置新的以太坊节点可能需要几天时间（有很多数据要同步，甚至可能比典型的笔记本电脑所能承受的带宽和存储更大）。

也就是说，为了避免这些麻烦，许多 DApp 选择使用 Infura 或 Alchemy 等服务来管理他们的节点基础设施。当然，这就存在一个权衡，因为这会创建一个集中式的瓶颈，但我们把这个问题留给另一天再讨论吧。

接下来，让我们来谈谈提供商。当你需要与区块链交互时（无论你是自己设置还是使用第三方服务的现有节点）连接的节点通常被称为“提供商”。

<div align=center><img src="./web3应用程序的架构/web3infra3.png" width="40%"/></div>

每个 Ethereum 客户端（即提供商）都实现了 JSON-RPC 规范。这确保了当前端应用程序希望与区块链交互时有一组统一的方法。如果你需要了解 JSON-RPC 的基础知识，它是一种无状态、轻量级的远程过程调用（RPC）协议，它定义了几种数据结构以及处理这些数据结构的规则。它是与传输无关的，因此这些概念可以在同一进程内使用，也可以通过套接字、HTTP 或许多各种消息传递环境使用。它使用 JSON（RFC 4627）作为数据格式。

一旦你通过提供商连接到区块链，就可以读取存储在区块链上的状态。但是，如果你想要写入状态，在将事务提交到区块链之前，你还需要做一件事，使用你的私钥“签署”事务。

例如，想象一下我们有一个 DApp，它允许用户读取或将博客文章发布到区块链上。你可能在前端有一个按钮，允许任何人查询某个特定用户写的博客文章。（记住，从区块链中读取不需要用户签署事务。）

这种“签署”事务通常是 Metamask 发挥作用的地方。

<div align=center><img src="./web3应用程序的架构/web3infra3.1.png" width="60%"/></div>

Metamask 是一种使应用程序轻松处理密钥管理和交易签名的工具。很简单：Metamask 在浏览器中存储用户的私钥，每当前端需要用户签署交易时，就会调用 Metamask。此外，Metamask 也提供了一个连接到区块链的通道（作为一个“提供商”），这是因为它已经与 Infura 提供的节点建立了连接，并且它需要它来签署交易。这样，Metamask 就既是一个提供商，也是一个签名者。

### 区块链存储

当然，如果您正在构建一个应用程序，其中所有智能合约和数据完全存储在以太坊区块链上，这种架构是有意义的。但是，任何在以太坊上构建应用程序的人都知道，将所有内容都存储在区块链上非常昂贵，而且速度非常慢。

请记住，在以太坊中，用户每次将新数据添加到区块链时都会付费。这是因为将状态添加到分散状态机会增加维护该状态机的节点的成本。

每次交易需要添加新状态时，要求用户额外支付使用 DApp 的费用并不是最佳用户体验。应对这种情况的一种方法是使用分散的离线存储解决方案，如 IPFS 或 Swarm。

IPFS 是一个用于存储和访问数据的分布式文件系统。因此，IPFS 系统不是将数据存储在集中式数据库中，而是将数据分布并存储在点对点网络中。这使您在需要时很容易检索它。另外 IPFS 还具有一个名为“Filecoin”的激励层。该层激励世界各地的节点存储和检索这些数据。您可以使用像 Infura（为您提供 IPFS 节点）或 Pinata（提供易于使用的服务，您可以将文件“固定”到 IPFS 上，并获取 IPFS 哈希并将其存储在区块链上）这样的提供商。

Swarm 类似，因为它是一个分布式存储网络，但有一个明显的区别。 Filecoin 是一个单独的系统，而 Swarm 的激励系统是内置的，并通过以太坊区块链上的智能合约来强制存储和检索数据。

所以现在，使用 IPFS 或 Swarm，我们的应用程序架构如下：
<div align=center><img src="./web3应用程序的架构/web3infra3.2.png" width="60%"/></div>

### 查询区块链

到目前为止，我们已经讨论了如何通过签署交易并将其发送到区块链来写入区块链。但是，从区块链上的智能合约读取数据怎么办？有两种主要方法：

1、Smart Contract Events <br> 您可以使用 Web3.js 库查询和监听智能合约事件。您可以监听特定事件，并每次触发事件时指定回调。例如，如果您有一个从 A 地址到 B 地址发送连续付款流的智能合约，那么您可以在每次向 B 地址支付时发出事件。您的前端代码可以监听智能合约发出的事件，并根据此执行特定操作。

2、The Graph <br> 上述方法可以使用，但有一些局限性。例如，如果您部署了一个智能合约，然后发现需要发出最初没有包含的事件，该怎么办？不幸的是，您必须重新部署一个带有该事件和数据的新智能合约。此外，使用回调来处理各种 UI 逻辑很快就会变得非常复杂。

这就用到了 The Graph。它是一种离线索引解决方案，使得更容易查询以太坊区块链上的数据。The Graph 允许您定义要索引的智能合约，要监听的事件和函数调用，以及将传入事件转换为前端逻辑（或使用 API 的任何内容）可以使用的实体的方式。它使用 GraphQL 作为查询语言，许多前端工程师喜欢它，因为与传统的 REST API 相比，它的表达能力很强。

通过对区块链数据进行索引，The Graph 允许我们在应用逻辑中以低延迟查询链上数据。

现在，我们的 DApp 架构如下所示：
<div align=center><img src="./web3应用程序的架构/web3infra3.3.png" width="60%"/></div>

我们就快完成了，但我们还有一个主要议题：扩展。

### 扩展 DApp

您可能已经听说，以太坊并不能扩展，至少暂时不能。

显然，这里有一个问题。在以太坊上构建具有高Gas费用和完整区块的 DApp 会导致非常糟糕的用户体验。幸运的是，有一些正在开发的解决方案。

一种流行的扩展解决方案是 Polygon，这是一种 L2 扩展解决方案。Polygon 不是在主区块链上执行交易，而是有“侧链”来处理和执行交易。侧链是与主链相连的辅助区块链。侧链定期向主链提交其最近区块的聚合。

<div align=center><img src="./web3应用程序的架构/sidechain.png" width="60%"/></div>

L2 解决方案的其他例子是 Optimistic Rollups 和 zkRollups。这里的想法是相似的：我们使用“rollup”智能合约在离线批处理交易，然后定期将这些交易提交到主链。

要记住的主要思想是：L2 解决方案在离线执行交易（即慢速部分），只在链上存储交易数据。这使我们能够扩展区块链，因为我们不必在链上执行每个交易。这也使交易更快，更便宜。并且在必要时仍然可以与主以太坊区块链进行通信。

<div align=center><img src="./web3应用程序的架构/web3infra3.4.png" width="60%"/></div>
